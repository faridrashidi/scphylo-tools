import os
import sys
import time

import numpy as np

import scphylo as scp


def scelestial(df_input):
    """Solving using Scelestial.

    Tree inference for single-cell data :cite:`Scelestial`.

    Parameters
    ----------
    df_input : :class:`pandas.DataFrame`
        Input genotype matrix in which rows are cells and columns are mutations.
        Values inside this matrix show the presence (1), absence (0) and missing
        entires (3).

    Returns
    -------
    :class:`pandas.DataFrame`
        A conflict-free matrix in which rows are cells and columns are mutations.
        Values inside this matrix show the presence (1) and absence (0).
    """
    executable = scp.ul.executable("scelestial", "scelestial")

    scp.logg.info(f"running Scelestial")

    tmpdir = scp.ul.tmpdirsys(suffix=".scelestial")

    np.savetxt(
        f"{tmpdir.name}/scelestial.SC.T", df_input.values.T, delimiter="\t", fmt="%1.0f"
    )
    with open(f"{tmpdir.name}/scelestial.cellNames", "w") as fout:
        fout.write("\n".join(df_input.index))

    _convert_input(f"{tmpdir.name}/scelestial.SC.T", f"{tmpdir.name}/scelestial.input")

    cmd = (
        f"{executable} < {tmpdir.name}/scelestial.input > "
        f"{tmpdir.name}/scelestial.tree_clone"
    )

    s_time = time.time()
    os.system(cmd)
    e_time = time.time()
    running_time = e_time - s_time

    _stein_to_clone_tree(
        f"{tmpdir.name}/scelestial.input",
        f"{tmpdir.name}/scelestial.tree_clone",
        f"{tmpdir.name}/scelestial.tree",
        f"{tmpdir.name}/scelestial.clone",
    )

    _clone_tree_to_mu_tree_imput(
        f"{tmpdir.name}/scelestial.tree",
        f"{tmpdir.name}/scelestial.clone",
        f"{tmpdir.name}/scelestial.SC.T",
        "/dev/null",
        f"{tmpdir.name}/scelestial.cellNames",
        f"{tmpdir.name}/scelestial.output",
    )

    tmpdir.cleanup()
    df_output = df_input

    scp.ul.stat(df_input, df_output, 0, 0, running_time)

    return df_output


def _convert_input(sciteFile_path, imputeFile_path, bpFile_path="/dev/null"):
    # Convert input-scite (which is generated by synthesis) to all other inputs,
    # including BitPhylogeny, Impute.

    sciteFile = open(sciteFile_path)
    imputeFile = open(imputeFile_path, "w+")
    bpFile = open(bpFile_path, "w+")

    seq = []
    for l in sciteFile:
        x = l.strip().split()
        for i, v in enumerate(x):
            while i >= len(seq):
                seq.append([])
            seq[i].append(int(v))

    loc = len(seq[0])
    for i in range(loc):
        print(f"{i + 1}", end=" ", file=imputeFile)
        for j in range(len(seq)):
            s = seq[j][i]
            if s == 0:
                ss = "A/A"
            elif s == 1:
                ss = "C/C"
            elif s == 2:
                ss = "A/C"
            elif s == 3:
                ss = "./."
            else:
                print(f"OH! {s}")
                raise (f"OH! {s}")
            print(f"{ss}", end=" ", file=imputeFile)
        print(file=imputeFile)

    for i in range(loc):
        print(f"V{i + 1}", end="", file=bpFile)
        if i != loc - 1:
            print(",", end="", file=bpFile)
    print(file=bpFile)

    for s in seq:
        first = True
        for v in s:
            if v == 3:
                v = 2
            elif v == 2:
                v = 1
            if not first:
                print(",", end="", file=bpFile)
            first = False
            print(f"{v}", end="", file=bpFile)
        print(file=bpFile)


def _stein_to_clone_tree(
    seqSciteFile_path, steinerFile_path, treeFile_path, cloneFile_path
):
    seqSciteFile = open(seqSciteFile_path)
    steinerFile = open(steinerFile_path)
    treeFile = open(treeFile_path, "w+")
    cloneFile = open(cloneFile_path, "w+")

    n = int(steinerFile.readline().strip())
    treeNodes = []
    cells = []
    maxAc = -1
    for i in range(n):
        l = steinerFile.readline().strip()
        x = l.split()
        treeNodes.append(x[0])
        if x[1] == "1":
            cells.append(x[0])
        ac = sum(1 for s in x[2] if s == "A")
        if ac > maxAc:
            maxAc = ac
            maxAcLen = len(x[2])
            treeRootSeqIdx = int(x[0])

    seqIdxToExclude = -1
    if maxAcLen == maxAc and 5 < len(sys.argv) and sys.argv[5] == "-exclude-root":
        seqIdxToExclude = treeRootSeqIdx

    cells = set(cells)

    for t in treeNodes:
        print(t, end=" ", file=cloneFile)
        if t in cells and t != seqIdxToExclude and int(t) != seqIdxToExclude:
            print(int(t) + 1, end="", file=cloneFile)
        if int(t) == treeRootSeqIdx:
            treeRootCloneIdx = int(t)
        print(file=cloneFile)

    print(" ".join(treeNodes), file=treeFile)

    edges = {}

    m = int(steinerFile.readline().strip())
    for i in range(m):
        l = steinerFile.readline().strip()
        x = l.split()
        if x[0] not in edges:
            edges[x[0]] = []
        if x[1] not in edges:
            edges[x[1]] = []
        edges[x[0]].append((x[1], x[2]))
        edges[x[1]].append((x[0], x[2]))

    mark = {}
    global dfsNumCounter
    dfsNumCounter = 0
    global dfsNum
    dfsNum = {}

    def dfs(v):
        global dfsNumCounter, dfsNum
        dfsNum[v] = dfsNumCounter
        dfsNumCounter += 1
        mark[v] = True
        for (u, _) in edges[v]:
            if u not in mark:
                dfs(u)

    dfs(str(treeRootCloneIdx))

    treeRootCloneIdx
    for v, nei in edges.items():
        for (u, w) in nei:
            if v < u:
                x, y = u, v
                if dfsNum[v] > dfsNum[u]:
                    x, y = v, u
                print(f"{x}->{y} {w}", file=treeFile)


def _clone_tree_to_mu_tree_imput(
    treeFileName,
    cloneFileName,
    seqFileName,
    mutationInfoFileName,
    cellNamesFileName,
    outputFileName,
    margeClones=False,
    markMutations=False,
    compress=False,
    markMutationsSeparated=False,
):
    import scipy.stats as stats
    from graphviz import Digraph

    def loadTree(treeFileName):
        treeFile = open(treeFileName)
        l = treeFile.readline()
        vertices = l.strip().split()
        edges = []
        treeParent = {}
        treeChildren = {}
        for l in treeFile:
            (e, w) = l.strip().split(" ")
            (v, u) = e.split("->")
            edges.append((v, u, float(w)))

            treeParent[v] = u
            if u not in treeChildren:
                treeChildren[u] = []
            treeChildren[u].append((v, float(w)))

        treeRoot = list(treeParent.keys())[0]
        while treeRoot in treeParent:
            treeRoot = treeParent[treeRoot]

        return vertices, edges, treeParent, treeChildren, treeRoot

    def loadClones(cloneFileName):
        cloneFile = open(cloneFileName)
        treeNodeCells = {}

        for l in cloneFile:
            x = l.strip().split()
            treeNodeCells[x[0]] = x[1:]

        return treeNodeCells

    def compressedTree(treeChildren, treeNodeCells, treeRoot):
        compressedTreeChildren = {}

        def dfs(v):
            ret = (None, None)
            children = []
            if v in treeChildren:
                for u, cw in treeChildren[v]:
                    c, w = dfs(u)
                    if c is not None:
                        w += cw
                        children.append((c, w))
                        ret = (c, w)

            if (
                (v in treeNodeCells and len(treeNodeCells[v]) > 0)
                or len(children) > 1
                or v == treeRoot
            ):
                ret = (v, 0)

            if ret == (v, 0):
                compressedTreeChildren[v] = []
                for c, cw in children:
                    compressedTreeChildren[v].append((c, cw))

            return ret

        dfs(treeRoot)
        return compressedTreeChildren

    def loadSequenceFile(seqFileName):
        sequences = []
        seqFile = open(seqFileName)
        for l in seqFile:
            for num, val in enumerate(l.strip().split()):
                while num >= len(sequences):
                    sequences.append([])
                sequences[num].append(int(val))
        return sequences

    def loadMutationInfoFile(mutationInfoFileName):
        mutationInfoFile = open(mutationInfoFileName)
        mutationInfo = []
        for l in mutationInfoFile:
            x = l.strip().split("\t")
            mutationInfo.append({"gene": x[11], "geneInfo": x[12], id: x[0]})
        return mutationInfo

    def writeGraph(
        outputFileName, treeNodeCells, nodes, edges, treeNodeDescColor, treeEdgeLabel
    ):
        dot = Digraph(format="pdf")
        dot.graph_attr["rankdir"] = "LR"
        for treeNode in nodes:
            # for treeNode, cells in treeNodeCells.items():
            cells = []
            if treeNode in treeNodeCells:
                cells = treeNodeCells[treeNode]
            prop = treeNodeDescColor(treeNode, cells)
            if len(prop) == 2:
                desc, col, fontcol, fillcol = prop[0], prop[1], "black", "none"
            else:
                desc, col, fontcol, fillcol = prop[0], prop[1], prop[2], prop[3]
            dot.node(
                treeNode,
                desc,
                color=col,
                fillcolor=fillcol,
                style="filled",
                fontcolor=fontcol,
                gradientangle="0",
                penwidth="4",
                shape="circle",
                margin="0",
            )

        for v, u, w in edges:
            tup = treeEdgeLabel(v, u, w)
            if isinstance(tup, tuple):
                label, edgecol = tup[0], tup[1]
            else:
                label, edgecol = tup, "black"
            dot.edge(u, v, weight=str(w), label=label, color=edgecol)

        dot.render(outputFileName)

    def loadFileRows(fileName):
        f = open(fileName)
        r = []
        for l in f:
            r.append(l.strip())
        return r

    def loadTable(fileName, sep="\t"):
        f = open(fileName)
        r = []
        for l in f:
            r.append(l.split(sep))
        return r

    def loadCellNames(cellNamesFileName):
        return loadFileRows(cellNamesFileName)

    def writeSequenceFile(sequences, fileName):
        f = open(fileName, "w")
        if len(sequences) > 0:
            for i in range(len(sequences[0])):
                print(" ".join([str(seq[i]) for seq in sequences]), file=f)
        f.close()

    BLUE = "#69c5f0"
    BLACK = "black"
    ORANGE = "#f57433"
    BROWN = "#af9d92"

    vertices, edges, treeParent, treeChildren, treeRoot = loadTree(treeFileName)
    treeNodeCells = loadClones(cloneFileName)

    sequences = loadSequenceFile(seqFileName)
    mutationInfo = loadMutationInfoFile(mutationInfoFileName)
    cellNames = loadCellNames(cellNamesFileName)

    if margeClones:

        def sameColon(v, u, w):
            m = len(sequences[0])
            pv = stats.binom_test(w, m, 0.2, alternative="less")
            print(f"same colon test: {w}/{m} = {pv}")
            return pv < 0.01

        mergeParent = {v: v for v in treeChildren.keys()}
        toBeMerged = {}
        for v, childrenDistList in treeChildren.items():
            for c, w in childrenDistList:
                if sameColon(v, c, w):
                    mergeParent[c] = v
                    toBeMerged[c] = True

        newTreeChildren = {v: [] for v in treeChildren.keys()}
        newTreeNodeCells = {v: [] for v in treeNodeCells.keys()}

        def dfs(v, firstKeptNode, wToHere):
            newTreeNodeCells[firstKeptNode] += treeNodeCells[v]
            if v in treeChildren:
                for u, w in treeChildren[v]:
                    if u not in toBeMerged:
                        newTreeChildren[firstKeptNode].append((u, wToHere + w))
                        dfs(u, u, 0)
                    else:
                        dfs(u, firstKeptNode, wToHere + w)

        dfs(treeRoot, treeRoot, 0)

        for v, childrenDistList in treeChildren.items():
            while mergeParent[mergeParent[v]] != mergeParent[v]:
                mergeParent[v] = mergeParent[mergeParent[v]]
            newTreeChildren[v]

        treeNodeCells = newTreeNodeCells
        treeChildren = newTreeChildren
        treeRoot = treeRoot

    treeNodeMutations = {}

    def fillTreeNodeMutations(mutIndex=None):
        allMutationCount = [
            [sum(1 for s in sequences if s[i] == mut) for mut in [0, 1]]
            for i, m in enumerate(mutationInfo)
        ]

        def dfs(v):
            myCellsStar = []
            if v in treeNodeCells:
                myCellsStar += [int(u) - 1 for u in treeNodeCells[v]]
            if v in treeChildren:
                for u, w in treeChildren[v]:
                    myCellsStar = dfs(u) + myCellsStar

            nodeMutations[v] = []
            for i, m in enumerate(mutationInfo):
                subTreeNormal, subTreeMutated = 0, 0
                for c in myCellsStar:
                    if sequences[c][i] == 0:
                        subTreeNormal += 1
                    if sequences[c][i] == 1:
                        subTreeMutated += 1

                if subTreeMutated > 0:
                    ignoremut = False
                    if v in treeChildren:
                        for u, w in treeChildren[v]:
                            smi = [
                                submut
                                for ii, submut, desc in nodeMutations[u]
                                if i == ii
                            ]
                            if len(smi) == 1 and smi[0] == subTreeMutated:
                                ignoremut = True
                    if not ignoremut:
                        nodeMutations[v].append(
                            (
                                i,
                                subTreeMutated,
                                str(subTreeNormal) + "," + str(len(myCellsStar)),
                            )
                        )
                    print(
                        "Mut:{} node: {} gene: {} cells:{} subtree: {},{}/{},{} "
                        .format(
                            i,
                            v,
                            m["gene"],
                            ",".join([cellNames[int(c) - 1] for c in treeNodeCells[v]]),
                            subTreeNormal,
                            subTreeMutated,
                            allMutationCount[i][0],
                            allMutationCount[i][1],
                        )
                    )
            return myCellsStar

        nodeMutations = {}
        dfs(treeRoot)
        for v, muts in nodeMutations.items():
            treeNodeMutations[v] = [
                mutationInfo[i]["gene"] + "/" + str(mut) + "," + str(desc)
                for i, mut, desc in muts
                if mutIndex is None or i == mutIndex
            ]

    if markMutations:
        fillTreeNodeMutations()

    nodes = list(treeNodeCells.keys())
    if compress:
        compressedTreeChildren = compressedTree(treeChildren, treeNodeCells, treeRoot)
        edges = []
        for par, cwList in compressedTreeChildren.items():
            for c, w in cwList:
                edges.append((c, par, w))
        nodes = list(compressedTreeChildren.keys())

    def treeNodeDescColor(treeNode, cells):
        desc = ", ".join([cellNames[int(c) - 1] for c in cells])
        return desc, BLUE, BLACK, BLUE

    def treeEdgeLabel(v, u, w):
        return "", "#A2A2A2"

    if markMutationsSeparated:
        for i, mut in enumerate(mutationInfo):
            fillTreeNodeMutations(i)
            writeGraph(
                outputFileName + "-" + str(i),
                treeNodeCells,
                nodes,
                edges,
                treeNodeDescColor,
                treeEdgeLabel,
            )
    else:
        writeGraph(
            outputFileName,
            treeNodeCells,
            nodes,
            edges,
            treeNodeDescColor,
            treeEdgeLabel,
        )
